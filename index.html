<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IBONIRIUM ¬∑ WILD PARK ¬∑ ETERNAL SYNC EXP-03</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            background: #000;
            overflow: hidden;
            font-family: monospace;
            cursor: crosshair;
        }

        canvas {
            position: fixed;
            inset: 0;
        }

        #sensors {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            height: 180px;
            pointer-events: none;
        }

        #info {
            position: fixed;
            bottom: 12px;
            left: 12px;
            color: #9affc2;
            font-size: 11px;
            line-height: 1.5;
            opacity: 0.9;
            text-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        #panel {
            position: fixed;
            bottom: 12px;
            right: 12px;
            max-width: 420px;
            color: #c7ffd9;
            font-size: 11px;
            line-height: 1.5;
            background: linear-gradient(to left, rgba(0, 0, 0, 0.75), transparent);
            padding: 14px 18px;
            border-right: 2px solid #0ff;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
            pointer-events: none;
        }

        #cycle {
            position: fixed;
            top: 12px;
            right: 12px;
            color: #ffd700;
            font-size: 13px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 14px;
            border-radius: 4px;
            pointer-events: none;
        }

        #treeInfo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            padding: 20px;
            border-radius: 8px;
            color: #0ff;
            max-width: 400px;
            display: none;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        #treeInfo h3 {
            margin-bottom: 10px;
            color: #0ff;
        }

        #treeInfo .close {
            position: absolute;
            top: 10px;
            right: 15px;
            cursor: pointer;
            font-size: 20px;
            color: #f00;
        }

        #eternalTimer b {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }
    </style>
</head>

<body>

    <canvas id="stars"></canvas>
    <canvas id="aurora"></canvas>
    <canvas id="forestBack"></canvas>
    <canvas id="forestMid"></canvas>
    <canvas id="forestFront"></canvas>
    <canvas id="sensors"></canvas>

    <div id="info">
        <b>IBONIRIUM ¬∑ WILD PARK ¬∑ EXP‚Äë03</b><br>
        Season: <span id="seasonDisplay" style="text-transform: uppercase; font-weight: bold;">Spring</span><br>
        Phase: <span id="phase">Wild Growth</span> | Cycle: <span id="cycleNum">1</span><br>
        Day: <span id="day">0</span> / 13<br>
        <br>
        <b>‚òÄ SOLAR DATA</b><br>
        SSN: <span id="ssn">‚Äì</span><br>
        Proton Flux: <span id="proton">‚Äì</span> pfu<br>
        Recent Flare: <span id="flare">None</span><br>
        <br>
        <b>üåç GEOMAGNETIC</b><br>
        Kp Index: <span id="kp">‚Äì</span><br>
        Solar Wind: <span id="wind">‚Äì</span> km/s<br>
        Bz: <span id="bz">‚Äì</span> nT<br>
        Electron Flux: <span id="electron">‚Äì</span><br>
        <br>
        <b>‚ö° PARK STATUS</b><br>
        Radiation: <span id="rad">Low</span><br>
        Storm Level: <span id="storm">Calm</span><br>
        Aurora: <span id="aurora">Inactive</span><br>
        Trees: <span id="treeCount">‚Äì</span>
    </div>

    <div id="panel">
        <b>–°–¢–ê–ù –ï–ö–°–ü–ï–†–ò–ú–ï–ù–¢–£: –î–ò–ö–ò–ô –ü–ê–†–ö</b><br>
        <div id="eternalTimer">–°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è —á–∞—Å—É...</div>
        <br>
        <b>–í–ø–ª–∏–≤–∏:</b><br>
        ‚Ä¢ SSN + Wind ‚Üí –¥–∏–∫–∏–π —Ä—ñ—Å—Ç —Ç–∞ –∞–≥—Ä–µ—Å–∏–≤–Ω–µ —Ä–æ–∑–≥–∞–ª—É–∂–µ–Ω–Ω—è<br>
        ‚Ä¢ –ü–æ—Ä–∏ —Ä–æ–∫—É ‚Üí –∑–º—ñ–Ω–∞ –∫–æ–ª—å–æ—Ä—É, –≥—É—Å—Ç–æ—Ç–∏ —Ç–∞ —Ñ–æ—Ä–º–∏ –∫—Ä–æ–Ω–∏<br>
        ‚Ä¢ Proton Flux ‚Üí —Ä–∞–¥—ñ–∞—Ü—ñ–π–Ω–µ –≤–∏–≥–æ—Ä–∞–Ω–Ω—è (–æ—Å—ñ–Ω–Ω—ñ–π –µ—Ñ–µ–∫—Ç)<br>
        ‚Ä¢ X/M Flares ‚Üí –µ–Ω–µ—Ä–≥–µ—Ç–∏—á–Ω—ñ —à–æ–∫–∏ (–¥–∏–∫—ñ —Å—Ç–∞–∑–∏)<br>
        ‚Ä¢ Kp Index ‚Üí –≥–µ–æ–º–∞–≥–Ω—ñ—Ç–Ω—ñ –∞–Ω–æ–º–∞–ª—ñ—ó —Ç–∞ —Å–≤—ñ—Ç—ñ–Ω–Ω—è<br>
        <br>
        <b>–°—Ç–∞—Ç—É—Å:</b> –î–∏–∫–∞ –µ–∫–æ—Å–∏—Å—Ç–µ–º–∞ –∞–¥–∞–ø—Ç—É—î—Ç—å—Å—è –¥–æ —Å–µ–∑–æ–Ω—ñ–≤ –ó–µ–º–ª—ñ.
    </div>

    <div id="cycle">
        üîÑ CYCLE <span id="cycleDisplay">1</span> | DAY <span id="dayDisplay">0</span>/13
    </div>

    <div id="treeInfo">
        <span class="close">‚úï</span>
        <h3>üå≤ Tree Analysis</h3>
        <div id="treeDetails"></div>
    </div>



    <script>
        // CANVAS
        const starC = document.getElementById('stars');
        const auroraC = document.getElementById('aurora');
        const forestBackC = document.getElementById('forestBack');
        const forestMidC = document.getElementById('forestMid');
        const forestFrontC = document.getElementById('forestFront');
        const sensC = document.getElementById('sensors');

        const sctx = starC.getContext('2d');
        const actx = auroraC.getContext('2d');
        const bctx = forestBackC.getContext('2d');
        const mctx = forestMidC.getContext('2d');
        const fctx = forestFrontC.getContext('2d');
        const ctxs = sensC.getContext('2d');

        function resize() {
            starC.width = auroraC.width = forestBackC.width = forestMidC.width = forestFrontC.width = sensC.width = innerWidth;
            starC.height = auroraC.height = forestBackC.height = forestMidC.height = forestFrontC.height = innerHeight;
            sensC.height = 180;
        }
        addEventListener('resize', resize); resize();

        // –ü–ê–†–ê–õ–ê–ö–°
        let mouseX = 0.5;
        let mouseY = 0.5;
        let targetMouseX = 0.5;
        let targetMouseY = 0.5;

        addEventListener('mousemove', (e) => {
            targetMouseX = e.clientX / innerWidth;
            targetMouseY = e.clientY / innerHeight;
        });

        function updateParallax() {
            mouseX += (targetMouseX - mouseX) * 0.05;
            mouseY += (targetMouseY - mouseY) * 0.05;
        }

        // –®–í–ò–î–ö–Ü–°–¢–¨ –°–ò–ú–£–õ–Ø–¶–Ü–á
        let timeSpeed = 1;

        // –ó–Ü–†–ö–ò –ó –ü–ê–†–ê–õ–ê–ö–°–û–ú
        const stars = Array.from({ length: 500 }, () => ({
            x: Math.random(),
            y: Math.random(),
            z: Math.random() * 0.8 + 0.2,
            twinkle: Math.random() * Math.PI * 2,
            speed: 0.3 + Math.random() * 0.7,
            layer: Math.random() < 0.3 ? 'back' : Math.random() < 0.6 ? 'mid' : 'front'
        }));

        function drawStars() {
            sctx.clearRect(0, 0, starC.width, starC.height);
            stars.forEach(s => {
                s.y += 0.0002 * s.speed * (1 + s.z * 2) * timeSpeed;
                if (s.y > 1) s.y = -0.01;
                s.twinkle += 0.03 * timeSpeed;
                const parallaxFactor = s.layer === 'back' ? 0.02 : s.layer === 'mid' ? 0.05 : 0.1;
                const px = s.x + (mouseX - 0.5) * parallaxFactor;
                const py = s.y + (mouseY - 0.5) * parallaxFactor * 0.5;
                const brightness = 0.3 + s.z * 0.5 + Math.sin(s.twinkle) * 0.2;
                sctx.globalAlpha = brightness;
                sctx.fillStyle = "#fff";
                sctx.beginPath();
                sctx.arc(px * starC.width, py * starC.height, s.z * 1.8, 0, Math.PI * 2);
                sctx.fill();
            });
        }

        // –î–ê–ù–Ü NOAA - RESTORED FULL API LOGIC
        let ssn = 0, protonFlux = 0, kpIndex = 0, solarWind = 400, bz = 0, electronFlux = 0;
        let radiationLevel = 0, stormLevel = 0, auroraActive = false;
        let recentFlare = { class: 'None', time: '' };

        async function updateSpaceWeather() {
            try {
                // Fetch all NOAA data in parallel
                const [rSSN, rProton, rFlare, rKp, rWind, rElectron] = await Promise.all([
                    fetch('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/goes/primary/integral-protons-plot-6-hour.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/goes/primary/xray-flares-7-day.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/planetary_k_index_1m.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/rtsw/rtsw_wind_1m.json').then(r => r.json()).catch(() => null),
                    fetch('https://services.swpc.noaa.gov/json/goes/primary/integral-electrons-plot-6-hour.json').then(r => r.json()).catch(() => null)
                ]);

                // SSN
                if (rSSN) ssn = rSSN[rSSN.length - 1]?.predicted_ssn || 15;

                // Proton Flux
                if (rProton) protonFlux = parseFloat(rProton[rProton.length - 1]?.flux) || 1;

                // Kp Index
                if (rKp) kpIndex = parseFloat(rKp[rKp.length - 1]?.kp_index) || 0;

                // Wind & Bz
                if (rWind && rWind.length > 0) {
                    const latestW = rWind[rWind.length - 1];
                    solarWind = parseFloat(latestW.wind_speed) || 400;
                    bz = parseFloat(latestW.bz) || 0;
                }

                // Electron Flux
                if (rElectron) electronFlux = parseFloat(rElectron[rElectron.length - 1]?.flux) || 100;

                // Flares
                if (rFlare && rFlare.length > 0) {
                    const flare = rFlare[rFlare.length - 1];
                    recentFlare = {
                        class: flare?.current_class || flare?.max_class || 'None',
                        time: flare?.peak_time || flare?.time_tag || ''
                    };
                }

                // COMPLEX INFLUENCE MAPPING
                let flareBoost = 0;
                if (recentFlare.class.startsWith('X')) flareBoost = 0.9;
                else if (recentFlare.class.startsWith('M')) flareBoost = 0.5;
                else if (recentFlare.class.startsWith('C')) flareBoost = 0.15;

                // Radiation depends on Protons + Flares
                radiationLevel = Math.min(1, (Math.log10(protonFlux + 1) / 5) + flareBoost * 0.7);

                // Storm depends on Kp + Negative Bz
                const bzFactor = bz < 0 ? Math.abs(bz) / 20 : 0;
                stormLevel = Math.min(1, (kpIndex / 9) + bzFactor * 0.3);

                auroraActive = kpIndex >= 5 || (kpIndex >= 3 && bz < -5);

                // UI Updates
                document.getElementById('ssn').textContent = ssn.toFixed(1);
                document.getElementById('proton').textContent = protonFlux.toFixed(2);
                document.getElementById('kp').textContent = kpIndex.toFixed(1);
                document.getElementById('wind').textContent = solarWind.toFixed(0);
                document.getElementById('bz').textContent = bz.toFixed(1);
                document.getElementById('electron').textContent = electronFlux.toFixed(0);
                document.getElementById('flare').textContent = recentFlare.class;

                document.getElementById('rad').textContent = radiationLevel < 0.2 ? 'Low' : radiationLevel < 0.5 ? 'Moderate' : radiationLevel < 0.8 ? 'High' : 'Severe';
                document.getElementById('storm').textContent = stormLevel < 0.2 ? 'Calm' : stormLevel < 0.5 ? 'Active' : stormLevel < 0.8 ? 'Storm' : 'Severe Storm';
                document.getElementById('aurora').textContent = auroraActive ? 'Active' : 'Inactive';
            } catch (e) {
                console.warn("NOAA API Sync Error, using fallback.");
                ssn = 15; protonFlux = 1; kpIndex = 1; solarWind = 400; bz = 0;
            }
        }
        updateSpaceWeather(); setInterval(updateSpaceWeather, 600000);

        // –ê–í–†–û–†–ê
        const auroraWaves = Array.from({ length: 8 }, (_, i) => ({ phase: Math.random() * Math.PI * 2, speed: 0.0008 + i * 0.0002, amplitude: 40 + i * 15 }));
        function drawAurora() {
            actx.clearRect(0, 0, auroraC.width, auroraC.height);
            if (!auroraActive && stormLevel < 0.3) return;
            const intensity = Math.max(stormLevel, auroraActive ? 0.6 : 0);
            auroraWaves.forEach((wave, idx) => {
                wave.phase += wave.speed * timeSpeed;
                const gradient = actx.createLinearGradient(0, 0, 0, auroraC.height * 0.5);
                gradient.addColorStop(0, `hsla(140, 80%, 60%, ${intensity * 0.15})`);
                gradient.addColorStop(0.5, `hsla(200, 90%, 50%, ${intensity * 0.25})`);
                gradient.addColorStop(1, "transparent");
                actx.fillStyle = gradient;
                actx.beginPath(); actx.moveTo(0, auroraC.height * 0.3);
                for (let x = 0; x <= auroraC.width; x += 15) {
                    const y = auroraC.height * 0.3 + Math.sin(x * 0.01 + wave.phase) * wave.amplitude * intensity;
                    actx.lineTo(x, y);
                }
                actx.lineTo(auroraC.width, 0); actx.lineTo(0, 0); actx.fill();
            });
        }

        // –ì–ï–û–ú–ê–ì–ù–Ü–¢–ù–Ü –•–í–ò–õ–Ü
        const geoWaves = [];
        function spawnGeoWave() {
            if (stormLevel > 0.4 && Math.random() < stormLevel * 0.02) {
                geoWaves.push({ x: Math.random() * innerWidth, y: forestMidC.height * 0.7, radius: 10, alpha: 0.8, hue: 180 + Math.random() * 60, layer: Math.random() < 0.5 ? 'mid' : 'front' });
            }
        }
        function drawGeoWaves(ctx, layer) {
            geoWaves.forEach((w, i) => {
                if (w.layer !== layer) return;
                w.radius += 2.5; w.alpha -= 0.01;
                if (w.alpha <= 0) { geoWaves.splice(i, 1); return; }
                ctx.strokeStyle = `hsla(${w.hue}, 90%, 60%, ${w.alpha})`; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2); ctx.stroke();
            });
        }

        const CYCLE_START = new Date('2026-01-01T00:00:00');

        function getSeason() {
            const m = new Date().getMonth();
            if (m >= 2 && m <= 4) return { name: 'Spring', hue: 100, lash: 1.0, wildness: 0.2 };
            if (m >= 5 && m <= 7) return { name: 'Summer', hue: 140, lash: 1.5, wildness: 0.5 };
            if (m >= 8 && m <= 10) return { name: 'Autumn', hue: 35, lash: 0.8, wildness: 0.8 };
            return { name: 'Winter', hue: 200, lash: 0.3, wildness: 0.1 };
        }

        // –î–ï–†–ï–í–ê (Eternal Growth Logic - RESTORED FULL INFLUENCE)
        class CosmicTree {
            constructor(x, layer) {
                this.x = x; this.layer = layer;
                this.type = Math.floor(Math.random() * 4);
                this.phase = Math.random() * Math.PI * 2;
                this.radiationDamage = 0;
                this.stormEnergy = 0;
                this.branchAngle = [0.55, 0.7, 0.45, 0.8][this.type];
                this.scale = layer === 'back' ? 0.6 : layer === 'mid' ? 0.85 : 1.0;
                this.opacity = layer === 'back' ? 0.4 : layer === 'mid' ? 0.7 : 1.0;

                // INITIALIZATION BASED ON REAL TIME SYNC
                const now = new Date();
                const totalDays = (now - CYCLE_START) / 86400000;
                this.cycleMemory = Math.floor(totalDays / 13);
                this.randomOffset = Math.random() * 2;

                // Persistent age: Base from memory + growth in current cycle
                this.updateInternalAge();
            }

            updateInternalAge() {
                const now = new Date();
                const totalDays = (now - CYCLE_START) / 86400000;
                const currentCycleDay = totalDays % 13;

                // Weather influence on growth speed
                const weatherFactor = (0.5 + ssn / 200 + solarWind / 2500);

                // Base age from completed cycles (e.g., 5 per cycle) + current day growth
                this.cycleMemory = Math.floor(totalDays / 13);
                this.age = 7 + (this.cycleMemory * 4) + (currentCycleDay * 0.3 * weatherFactor) + this.randomOffset;
            }

            grow() {
                this.updateInternalAge();

                // Sync weather-based modifiers (no direct age increment to avoid playback)
                let flareBoost = 1;
                if (recentFlare.class.startsWith('X')) flareBoost = 2.2;
                else if (recentFlare.class.startsWith('M')) flareBoost = 1.5;
                if (electronFlux > 1500) flareBoost *= 1.3;

                // Radiation damage and storm energy still accumulate/heal per frame
                this.radiationDamage = Math.max(0, Math.min(1, this.radiationDamage + (radiationLevel * 0.005) - 0.001));
                this.stormEnergy = Math.max(0, Math.min(1, this.stormEnergy + (stormLevel * 0.01) - 0.005));
            }

            draw(ctx) {
                const season = getSeason();
                const baseY = ctx.canvas.height * 0.78;
                const parallax = this.layer === 'back' ? 0.03 : this.layer === 'mid' ? 0.06 : 0.12;
                let x = (this.x + (mouseX - 0.5) * parallax) * ctx.canvas.width;
                let y = baseY + (mouseY - 0.5) * parallax * 50;

                // Seasonal and Wildness influencers
                let len = (60 + this.cycleMemory * 12) * this.scale * (0.8 + season.lash * 0.4);

                const time = Date.now() * 0.001;
                const windMod = (solarWind / 1200);
                const swayFreq = 0.2 + windMod + season.wildness * 0.5;
                const swayAmp = 0.03 + windMod * 0.1 + season.wildness * 0.2;
                const treeSway = Math.sin(time * swayFreq + this.phase) * swayAmp;

                let angle = -Math.PI / 2 + treeSway;

                // Color mapping: Weather + Season + Radiation
                let baseHue = season.hue;
                if (season.name === 'Autumn') baseHue -= this.radiationDamage * 30; // More red if damaged
                else if (season.name === 'Spring') baseHue += this.stormEnergy * 40; // More cyan if high energy

                let hue = baseHue - this.radiationDamage * 60 + this.stormEnergy * 30;
                let sat = 60 + this.stormEnergy * 40 - (season.name === 'Winter' ? 40 : 0);
                let light = 45 + this.stormEnergy * 20 + (season.name === 'Winter' ? 20 : 0);

                ctx.strokeStyle = `hsl(${hue}, ${sat}%, ${light}%)`;
                ctx.globalAlpha = this.opacity;

                const segments = Math.floor(Math.min(60, this.age * (0.5 + season.lash)));
                for (let i = 0; i < segments; i++) {
                    const nx = x + Math.cos(angle) * len;
                    const ny = y + Math.sin(angle) * len;

                    // Thicker roots, thinner tips, wilder distortion
                    ctx.lineWidth = (len * 0.18) * (1 - i / segments * 0.8) * (1 + this.stormEnergy * 0.4);
                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(nx, ny); ctx.stroke();

                    // Wild distortion based on season and weather
                    const distortion = Math.sin(i * 1.5 + this.phase + time * 0.5) * this.branchAngle * (1 + season.wildness);
                    angle += distortion + (Math.random() - 0.5) * 0.1 * season.wildness;

                    x = nx; y = ny;
                    len *= (0.68 + (season.name === 'Winter' ? -0.05 : 0.02));
                }

                // Crown - ALWAYS VISIBLE WILD SHAPES
                const crownBase = (18 + this.radiationDamage * 12 + this.stormEnergy * 20 + this.cycleMemory * 3) * this.scale;
                const crownSize = crownBase * (0.7 + season.lash * 0.5);

                ctx.fillStyle = `hsla(${hue + 20}, ${sat}%, ${light + 10}%, ${0.6 + this.stormEnergy * 0.3})`;

                // Wild Park Crown - Jagged/Organic
                ctx.beginPath();
                const points = 5 + Math.floor(this.type * 2);
                for (let p = 0; p < points * 2; p++) {
                    // In winter, make crowns more sharp/crystalline
                    const wildFactor = season.name === 'Winter' ? 0.3 : season.wildness;
                    const r = (p % 2 === 0) ? crownSize : crownSize * (0.5 + wildFactor * 0.5);
                    const currAngle = (p / points) * Math.PI + time * 0.2;
                    const px = x + Math.cos(currAngle) * r;
                    const py = y + Math.sin(currAngle) * r;
                    if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath(); ctx.fill();

                // Inner Glow - Dynamic Core
                ctx.fillStyle = `hsla(${hue + 60}, 100%, 82%, ${0.5 + this.stormEnergy * 0.4})`;
                ctx.beginPath(); ctx.arc(x, y, crownSize * 0.35, 0, Math.PI * 2); ctx.fill();

                this.screenX = x; this.screenY = y; this.screenR = 40 * this.scale;
            }

            getInfo() {
                const s = getSeason();
                return `<b>Wild Type:</b> ${['Gnarly', 'Prickly', 'Spiked', 'Ancient'][this.type]}<br><b>Season:</b> ${s.name}<br><b>Age:</b> ${this.age.toFixed(1)}<br><b>Energy:</b> ${(this.stormEnergy * 100).toFixed(0)}%`;
            }
        }

        // –í–£–õ–ò–ß–ù–ò–ô –õ–Ü–•–¢–ê–† (Celestial NOAA Lantern - Redesigned)
        class AncientStatue {
            constructor(x) {
                this.x = x;
            }

            draw(ctx) {
                const season = getSeason();
                const baseY = ctx.canvas.height * 0.78;
                const parallax = 0.15;
                const x = (this.x + (mouseX - 0.5) * parallax) * ctx.canvas.width;
                const y = baseY + (mouseY - 0.5) * parallax * 50;

                const time = Date.now() * 0.001;
                const flareActive = recentFlare.class !== 'None' && recentFlare.class !== 'C0.0';

                // --- NOAA REACTIVE LIGHT LOGIC ---
                let lightHue = flareActive ? 0 : (180 + stormLevel * 100); // Red if Flare, Cyan/Blue if Storm
                let intensity = 0.6 + stormLevel * 0.4 + (flareActive ? 0.4 : 0);
                let flicker = 0.9 + Math.sin(time * 20) * 0.1 * stormLevel; // Flicker during storms

                ctx.save();
                ctx.translate(x, y);

                // --- THE LIGHT BEAM (Cone of Light) ---
                const beamReach = 200 + intensity * 100;
                const beamWidth = 80 + intensity * 40;
                const grad = ctx.createLinearGradient(0, -180, 0, 0);
                grad.addColorStop(0, `hsla(${lightHue}, 100%, 80%, ${0.4 * intensity * flicker})`);
                grad.addColorStop(0.5, `hsla(${lightHue}, 100%, 60%, ${0.15 * intensity})`);
                grad.addColorStop(1, `hsla(${lightHue}, 100%, 50%, 0)`);

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(0, -180);
                ctx.lineTo(-beamWidth, 0);
                ctx.lineTo(beamWidth, 0);
                ctx.closePath();
                ctx.fill();

                // --- THE LANTERN POST ---
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -180);
                ctx.stroke();

                // Decorative Ancient Rims
                ctx.strokeStyle = `hsla(${lightHue}, 100%, 70%, 0.4)`;
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    ctx.strokeRect(-4, -i * 22 - 20, 8, 4);
                }

                // --- THE LANTERN HEAD ---
                ctx.save();
                ctx.translate(0, -190);

                // Top Cap
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.moveTo(-25, 10); ctx.lineTo(25, 10);
                ctx.lineTo(0, -10);
                ctx.closePath();
                ctx.fill();

                // Light Core (The Bulb)
                const glowSize = 15 + intensity * 10;
                ctx.shadowBlur = glowSize * 2;
                ctx.shadowColor = `hsla(${lightHue}, 100%, 60%, 1)`;
                ctx.fillStyle = `hsla(${lightHue}, 100%, 90%, ${flicker})`;
                ctx.beginPath();
                ctx.arc(0, 15, 10, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Pedestal Base
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(-20, -8, 40, 16);
                ctx.strokeStyle = `hsla(${lightHue}, 100%, 50%, 0.5)`;
                ctx.strokeRect(-20, -8, 40, 16);

                ctx.restore();

                this.screenX = x; this.screenY = y - 190; this.screenR = 100;
            }

            getInfo() {
                const flareStr = recentFlare.class !== 'None' ? `Flare: ${recentFlare.class}` : 'Stable';
                return `<b>Type:</b> Celestial NOAA Lantern<br><b>Light Source:</b> Solar Energy<br><b>Sky Condition:</b> ${flareStr}<br><b>Luminosity:</b> ${(stormLevel * 100).toFixed(0)}%`;
            }
        }

        const statue = new AncientStatue(0.75); // Position at 75% width

        const trees = {
            back: Array.from({ length: 25 }, () => new CosmicTree(Math.random(), 'back')),
            mid: Array.from({ length: 35 }, () => new CosmicTree(Math.random(), 'mid')),
            front: Array.from({ length: 25 }, () => new CosmicTree(Math.random(), 'front'))
        };
        const allTrees = [...trees.back, ...trees.mid, ...trees.front];

        document.getElementById('treeCount').textContent = allTrees.length;

        forestFrontC.addEventListener('click', e => {
            const rect = forestFrontC.getBoundingClientRect();
            const tx = e.clientX - rect.left, ty = e.clientY - rect.top;

            // Check Statue first
            const sDist = Math.sqrt((statue.screenX - tx) ** 2 + (statue.screenY - ty) ** 2);
            if (sDist < statue.screenR) {
                document.getElementById('treeDetails').innerHTML = statue.getInfo();
                document.getElementById('treeInfo').style.display = 'block';
                return;
            }

            const target = allTrees.find(t => Math.sqrt((t.screenX - tx) ** 2 + (t.screenY - ty) ** 2) < t.screenR);
            if (target) {
                document.getElementById('treeDetails').innerHTML = target.getInfo();
                document.getElementById('treeInfo').style.display = 'block';
            }
        });
        document.querySelector('.close').onclick = () => document.getElementById('treeInfo').style.display = 'none';

        const particles = [];
        function spawnParticle() { if (Math.random() < radiationLevel * 0.15) particles.push({ x: Math.random() * innerWidth, y: -20, vy: 2 + Math.random() * 5, layer: Math.random() < 0.5 ? 'mid' : 'front' }); }
        function drawParticles(ctx, layer) {
            particles.forEach((p, i) => {
                if (p.layer !== layer) return;
                p.y += p.vy; if (p.y > ctx.canvas.height) particles.splice(i, 1);
                ctx.fillStyle = "#0ff"; ctx.globalAlpha = 0.6; ctx.fillRect(p.x, p.y, 2, 10);
            });
        }

        function updateCycleSystem() {
            const now = new Date();
            const totalMs = now - CYCLE_START;
            const totalDays = totalMs / 86400000;
            const daysInt = Math.floor(totalDays);
            const currentCycle = Math.floor(daysInt / 13) + 1;
            const currentDay = daysInt % 13;
            const h = Math.floor((totalMs / 3600000) % 24);
            const m = Math.floor((totalMs / 60000) % 60);
            const s = Math.floor((totalMs / 1000) % 60);

            document.getElementById('eternalTimer').innerHTML = `<b>–ß–∞—Å –±—É—Ç—Ç—è:</b> ${daysInt}–¥ ${h}–≥ ${m}—Ö–≤ ${s}—Å`;
            document.getElementById('day').textContent = currentDay;
            document.getElementById('cycleNum').textContent = currentCycle;
            document.getElementById('cycleDisplay').textContent = currentCycle;
            document.getElementById('dayDisplay').textContent = currentDay;

            // Update Phase Display
            const phaseEl = document.getElementById('phase');
            const season = getSeason();
            document.getElementById('seasonDisplay').textContent = season.name;
            document.getElementById('seasonDisplay').style.color = season.name === 'Winter' ? '#8cf' : season.name === 'Autumn' ? '#f80' : season.name === 'Spring' ? '#afa' : '#fd0';

            if (currentDay < 9) phaseEl.textContent = "Wild Growth";
            else if (currentDay < 12) phaseEl.textContent = "Overgrowth";
            else phaseEl.textContent = "Peak Vitality";

            // SYNC UPDATE
            if (m === 0 && s === 0) {
                // Periodic memory sync check
                allTrees.forEach(t => t.updateInternalAge());
            }
        }
        setInterval(updateCycleSystem, 1000); updateCycleSystem();

        function loop() {
            updateParallax(); drawStars(); drawAurora(); drawGeoWaves(mctx, 'mid'); drawGeoWaves(fctx, 'front');
            bctx.clearRect(0, 0, innerWidth, innerHeight); trees.back.forEach(t => { t.grow(); t.draw(bctx); });
            mctx.clearRect(0, 0, innerWidth, innerHeight); trees.mid.forEach(t => { t.grow(); t.draw(mctx); }); drawParticles(mctx, 'mid');
            fctx.clearRect(0, 0, innerWidth, innerHeight);
            trees.front.forEach(t => { t.grow(); t.draw(fctx); });
            statue.draw(fctx); // Draw Statue in Front Layer
            drawParticles(fctx, 'front');
            spawnParticle(); spawnGeoWave();
            requestAnimationFrame(loop);
        }
        loop();
    </script>
</body>

</html>
